<!-- TOC -->

- [toy-gc](#toy-gc)
    - [少用，重用，循环用](#少用重用循环用)
    - [标记-清除](#标记-清除)

<!-- /TOC -->
# toy-gc
C语言实现gc的标记清除算法
## 少用，重用，循环用
垃圾回收思想是源于编程语言似乎需要无穷尽的内存。开发人员可以一直一直的分配内存，它就像是魔法一般，永远不会失败。

当然了，机器的内存不可能是无限的。所以解决办法就是，当程序需要分配内存并且意识到内存已经不足了，它开始进行垃圾回收。

在这里，“垃圾”是指那些已经分配出去但现在不再使用的内存。为了让内存看起来是取之不尽的，语言本身应当十分谨慎地定义什么是“不再使用的”。不然的话当你的程序正要访问那些对象的时候，你却要回收它们，这可不是闹着玩的。

为了能进行垃圾回收，语言本身得确定程序无法再使用这些对象。如果拿不到对象的引用，当然也就无法使用它们了。那么定义什么是“在使用中的”就很简单了：

- 如果对象被作用域中的变量引用的话，那么它就是在使用中的；

* 如果对象被在使用中的对象引用的话，那么它也是在使用中的。

第二条规则是递归的。如果对象A被一个变量引用，并且它有个字段引用了对象B，那么B也是正在使用中的，因为通过A你能对它进行访问。

最后就是一张可达对象的图了——以一个变量为起点，你能够遍历到的所有对象。不在这张可达对象图里的对象对程序来说都是没用的，那么它占有的内存就可以回收了。

## 标记-清除

查找及回收无用对象的方法有很多种，最简单也是最早的一种方法，叫“标记-清除法”。它是由John McCathy发明的，他同时还发明了Lisp和大胡子（译注:请自觉搜索下他的照片），因此你用它来实现的话就像是和远古大神交流一般，不过希望你可别搞成通灵啥的，不然我怕你会神志不清，出现幻觉。

这和我们定义可达性的过程简直是一样的：

- 从根对象开始，遍历整个对象图。每访问一个对象，就把一个标记位设成true。
- 一旦完成遍历，找出所有没有被标记过的对象，并清除掉它们。

这样就OK了。
